# 1. 발제자가 준비한 질문

## Wrapper Class 

### 래퍼 클래스를 사용하는 이유

- 기본데이터타입을 객체로 변환  
java.util 패키지의 클래스는 객체만 처리하므로 기본데이터타입을 래퍼클래스로 사용  
Collection 프레임워크 데이터구조(ArrayList) 등은 객체만 처리하므로 기본데이터타입을 래퍼클래스로 사용  
(제네릭 활용가능. 제네릭은 데이터형식에 의존하지 않고 하나의 값이 여러 데이터타입들을 가질 수 있도록 함)  
null값 가능  
메소드 사용가능(문자열 변환 등)  
멀티스레딩 환경에서 동기화 지원하고 싶을때  


### 기본 형과 래퍼 클래스의 객체 타입의 차이점 2가지

- 기본자료형 vs 참조자료형  
기본자료형의 데이터 값을 변경하면 해당 메모리 내부의 값이 변경되지만(데이터 내부값 변경)  
참조자료형인 래퍼클래스는 새로운 인스턴스를 생성하고 새인스턴스의 주소를 참조한다(참조변경)  
  
- 산술연산 여부  
기본자료형은 산술연산이 자유롭지만  
래퍼클래스는 언박싱으로 기본자료형변경 후에 연산이 가능하다  
(JDK 1.5부터 컴파일러가 오토박싱, 오토언박싱 지원)   
  
- 메모리할당량 차이  
기본자료형은 boolean 1bit  
래퍼클래스 기본적으로 16바이트 이상. Boolean 128bit  
  
- 접근속도 차이  
원시타입은 스택메모리에 존재  
객체타입은 참조타입. 실제값은 힙메모리에 존재하고 스택메모리에는 참조값만 있음  
아울러 박싱/언박싱 과정이 더해지면 접근속도가 느려짐  

![접근속도차이](https://blog.kakaocdn.net/dn/uj0bm/btqvqfnwD5S/tKWdT5AKJDttoyuF5baZZK/img.gif)


### 래퍼 클래스 값을 비교하는 방법

래퍼클래스는 객체이므로 비교연산을 하면  
데이터 내부 값이아니라 두 인스턴스의 주소값을 비교하게 된다.  
  
1) 기본데이터타입으로 언박싱해서 비교  
2) 동등비교의경우  equals() 메소드 사용  


### JDK 1.8(== Java 8) 부터 추가된 기능

오라클 인수 후 첫번째 버전(2014년 발표)  
  
- Lambda 표현 지원 : 무명함수  
  
- 메소드 참조 : 람다식을 메서드참조로 변경 가능. Integer의 parseInt를 Integer::parseInt로 가능  
람다식 (String x) -> Integer.parseInt(x)  
메소드참조 Integer::paseInt  
  
- 인터페이스 스테틱 메소드 선언가능   
  
- 인터페이스 디폴트 메소드 : 인터페이스 내부에 로직을 포함한 메소드 작성가능.  
하위호환성 지향.  
기존에는 인터페이스에서 메소드를 선언만하고  
인터페이스를 상속받는 모든 클래스에 각각 메소드를 개별적으로 구현해야했음.  
디폴트 메소드로 선언한다면 별도의 오버라이딩 필요없음. 필요시에 오버라이딩 가능  
  
- Streams 기능 추가 :   
데이터흐름. 기존에 배열/컬렉을 다룰때 반복문 돌리면서 요소 하나씩 꺼내던 방법을 개선.  
원하는 결과를 필터링/맵핑하여 가공된 결과를 얻을 수 있음. 멀티스레딩 가능  
반복문 코드대신 깔끔하고 간결한 코드를 짤 수 있음.  
  
- Optional : Optional 객체로 null 값 처리  
  
- new Date and Time API(LocalDateTime, …) 추가  



## StringBuilder, StringBuffer

### String vs StringBuilder, StringBuffer 차이
  
String클래스는 불변성(immutable) 클래스.   
문자열을 추가, 수정, 삭제등 작업을 하면   
Stirng클래스는 매번 새로운 객체를 만들어 새로운 메모리영역을 참조함.  
문자열 연산작업을 할수록 기존의 객체는 힙메모리에 남아 많은 임시 가비지가 생성(GC대상)   
힙메모리 부족으로  프로그램 성능저하 발생.  
  
StringBuilder와 StringBuffer는 가변성(mutable) 클래스  
String클래스 연산으로 인한 프로그램 성능저하를 해결하기 위해 만들어짐.  
문자열이 더해져도 새로운 객체 생성하지 않고,  
기존 객체의 데이터를 변경.  
StringBuilder와 StringBuffer는 AbstractStringBuilder 라는 추상 클래스를 상속받아 구현.  
StringBuilder와 StringBuffer 클래스의 문자열을 수정하고 싶으면 append() 메서드를 사용.  
추가할 문자열의 길이만큼 배열의 공간을 늘려주고, 늘려준 공간에 추가할 문자열을 넣어주는 방식  
  

### StringBuilder vs StringBuffer 차이

멀티스레드 안전성 여부.  

StringBuffer : 동기화함. 멀티스레드 환경에서도 안전  
A스레드와 B스레드에서 동시에 append() 메서드를 사용하려고 하면,  
A스레드가 동기화 블록에 접근하여 메서드 실행.  
B스레드는 동기화 블록에 들어가지 못하고 대기. A스레드가 동기화블록에서 탈출해야 접근 및 실행 가능  
멀티스레드 환경(병행실행)에서 스레드 안전성 보장.  
  
StringBuilder : 동기화하지 않음. 속도가 빠르다.   
싱글스레드 환경(순차실행)에서 StringBuffer보다 성능면에서 유리  
  
String은 JVM의 String constant pool에서 특별히 관리되고 있어 스레드에 안정적  
두개의 같은 String 변수가 동일한 값을 가지면 동일한 메모리를 가짐  


### JDK 1.5 부터 String 연산시 변경짐  
컴파일시 String 연산이 최적화됨.  
String객체를 더할 때, 컴파일러가 자동으로 StringBuffer의 append, toString메서드를 사용하는 코드로 처리함  
String클래스 연산의 성능저하 개선.  
한번의 연산에 있어서 String과 StringBuilder, StringBuffer의 차이는 거의 없다고함.  
  
String객체를 반복문 등에서 여러번 더하는 작업을 할 때   
더하기 연산때마다 새로운 StringBuilder 클래스를 객체를 계속 추가해야하므로,   
문자열 더하는 작업이 많다면 StirngBuilder 클래스를 쓰는게 좋다.  




# 2. 내가 준비한 질문

- 상수와 불변성의 차이

- 리터럴과 데이터의 차이

- 멀티스레드 환경에서 non-thread-safe가 초래할 수 있는 상황
